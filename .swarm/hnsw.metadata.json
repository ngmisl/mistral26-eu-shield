[["entry_1772271995157_zhifau",{"id":"entry_1772271995157_zhifau","key":"eu-shield-architecture","namespace":"patterns","content":"EU Shield Chrome extension architecture:\n- TypeScript + Zod + Effect + Zustand stack\n- WXT framework for Manifest V3\n- 3-layer detection pipeline: URL matching -> Content analysis -> Path probing\n- 20 GDPR patterns (15 positive, 5 red flags) with multi-language support\n- Effect-based async pipelines with proper error handling\n- Zustand state management for popup UI\n- 7-day caching with Zod validation\n- SVG icons with programmatic PNG generation"}],["entry_1772272007644_ssfz",{"id":"entry_1772272007644_ssfz","key":"eu-shield-implementation","namespace":"patterns","content":"Successful EU Shield implementation approach:\n1. Created all Zod schemas first as single source of truth\n2. Implemented patterns with multi-language regex support\n3. Built pure scorer function with conditional logic\n4. Created Effect-based detector with fallback strategies\n5. Added cache layer with Zod validation\n6. Implemented message protocol with validation\n7. Built background service worker for orchestration\n8. Created content script for detection execution\n9. Developed popup UI with Zustand state management\n10. Generated SVG icons and converted to PNG\n11. Added comprehensive test suite\n12. Fixed TypeScript type issues systematically"}],["entry_1772272019715_i7f4f8",{"id":"entry_1772272019715_i7f4f8","key":"chrome-extension-typescript-pattern","namespace":"patterns","content":"Effective TypeScript pattern for Chrome extensions:\n- Use Zod for all runtime validation (messages, cache, config)\n- Infer types from Zod schemas to avoid duplication\n- Use Effect for async pipelines with proper error handling\n- Zustand/vanilla for state management without React\n- WXT framework for Manifest V3 configuration\n- Separate concerns: schemas -> patterns -> scorer -> detector -> cache -> messages\n- Test critical paths: validation, scoring, detection, caching"}],["entry_1772273145607_izfya8",{"id":"entry_1772273145607_izfya8","key":"chrome-extension-message-handling","namespace":"patterns","content":"Chrome extension message handling pattern:\n- Always wrap chrome.tabs.sendMessage in try-catch\n- Handle 'Receiving end does not exist' errors gracefully\n- Provide fallback behavior when content script is not ready\n- Use async/await for proper error handling\n- Log warnings for debugging but don't break functionality\n- Example:\n```typescript\ntry {\n  await chrome.tabs.sendMessage(tabId, message);\n} catch (error) {\n  console.warn('Content script not ready:', error);\n  // Provide fallback behavior\n}\n```"}],["entry_1772273182148_1jkpos",{"id":"entry_1772273182148_1jkpos","key":"chrome-extension-hmr-handling","namespace":"patterns","content":"Successful pattern for handling Chrome extension HMR (Hot Module Replacement):\n- Content scripts get reloaded during development\n- Background scripts may try to communicate while content script is reloading\n- Solution: Wrap all chrome.tabs.sendMessage calls in try-catch\n- Provide graceful fallback behavior (e.g., grey icon)\n- Log warnings for debugging but don't break functionality\n- Expected warnings during HMR are normal and indicate proper error handling\n- Example warnings:\n  - 'Could not establish connection. Receiving end does not exist.'\n  - 'A listener indicated an asynchronous response by returning true, but the message channel closed before a response was received'"}],["entry_1772273289916_wiqi9s",{"id":"entry_1772273289916_wiqi9s","key":"wxt-content-script-configuration","namespace":"patterns","content":"WXT content script configuration pattern:\n- Must declare content scripts in wxt.config.ts manifest.content_scripts\n- WXT will automatically handle the build process\n- Content scripts get injected into matching pages automatically\n- Example configuration:\n```typescript\nmanifest: {\n  content_scripts: [\n    {\n      matches: ['<all_urls>'],\n      js: ['content.ts'],\n      run_at: 'document_idle'\n    }\n  ]\n}\n```\n- Without this declaration, content scripts won't be injected\n- WXT generates proper manifest.json with content script declarations"}],["entry_1772273459601_2ey1m",{"id":"entry_1772273459601_2ey1m","key":"chrome-extension-message-response","namespace":"patterns","content":"Chrome extension message response handling pattern:\n- Use chrome.runtime.sendMessage with callback parameter for responses\n- Don't use separate message listeners when expecting direct responses\n- Handle chrome.runtime.lastError for error cases\n- Example:\n```typescript\nchrome.runtime.sendMessage(message, (response) => {\n  if (chrome.runtime.lastError) {\n    console.error('Message failed:', chrome.runtime.lastError);\n    // Handle error\n    return;\n  }\n  \n  if (response) {\n    // Process successful response\n  }\n});\n```\n- This pattern works for request/response message flows\n- Background scripts use sendResponse() to send back results\n- Popup/content scripts use callbacks to receive responses"}],["entry_1772273634996_8bwe9v",{"id":"entry_1772273634996_8bwe9v","key":"chrome-extension-message-callback","namespace":"patterns","content":"Chrome extension message callback pattern for popup/content scripts:\n- Always provide callback functions for chrome.runtime.sendMessage\n- Even if you don't expect a response, handle potential errors\n- Prevents 'message channel closed' errors\n- Example:\n```typescript\nchrome.runtime.sendMessage(message, (response) => {\n  if (chrome.runtime.lastError) {\n    console.error('Message failed:', chrome.runtime.lastError);\n    // Handle error appropriately\n  }\n  // Process response if needed\n});\n```\n- This pattern ensures proper message channel cleanup\n- Prevents memory leaks and channel errors\n- Works for both request/response and fire-and-forget messages"}]]